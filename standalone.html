<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Concept Board</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useMemo, useRef } = React;

    const BACKEND_URL = "";

    const MODEL_OPTIONS = [
      { id: "seedream_4", label: "Seedream 4", apiModel: "bytedance/seedream-v4-text-to-image", apiEditModel: "bytedance/seedream-v4-edit" },
      { id: "nano_banana", label: "Nano Banana", apiModel: "google/nano-banana", apiEditModel: "google/nano-banana-edit" },
      { id: "gpt4o_image", label: "GPT-4o Image", apiType: "gpt4o" },
      { id: "flux_kontext", label: "Flux Kontext", apiType: "flux_kontext", supportsImageToImage: true },
      { id: "imagen4", label: "Imagen 4", apiModel: "google/imagen4" },
      { id: "ideogram", label: "Ideogram", apiModel: "ideogram/v3-text-to-image", apiEditModel: "ideogram/v3-edit" },
      { id: "development", label: "Development", apiType: "mock" },
    ];

    async function fetchAudioOptions() {
      try {
        const token = await getGoogleAccessToken();
        const res = await fetch(
          `${BACKEND_URL}/api/sheets/read?range=Song_Audio!A2:F`,
          { headers: { "Authorization": `Bearer ${token}` } }
        );
        const data = await res.json();
        return (data.values || []).map(row => ({
          clip_id: row[0] || "",
          song_id: row[1] || "",
          song_name: row[2] || "",
          lyric: row[3] || "",
          length: row[4] || "",
          audio_link: row[5] || ""
        }));
      } catch (err) {
        console.error("Failed to fetch audio options:", err);
        return [];
      }
    }

    async function fetchReferenceImages() {
      try {
        const token = await getGoogleAccessToken();
        const res = await fetch(
          `${BACKEND_URL}/api/sheets/read?range=ReferencesLookup!B:B`,
          { headers: { "Authorization": `Bearer ${token}` } }
        );
        const data = await res.json();
        console.log("Reference images data:", data);
        const urls = (data.values || []).map(row => {
          let url = row[0];
          if (!url || !url.startsWith('http')) return null;
          // Convert Google Drive URLs to direct image URLs
          if (url.includes('drive.google.com')) {
            const match = url.match(/\/d\/([^\/]+)/) || url.match(/[?&]id=([^&]+)/);
            if (match) {
              url = `https://drive.google.com/thumbnail?id=${match[1]}&sz=w400`;
            }
          }
          return url;
        }).filter(url => url);
        console.log("Filtered reference image URLs:", urls);
        return urls;
      } catch (err) {
        console.error("Failed to fetch reference images:", err);
        return [];
      }
    }

    function makeConceptId() {
      const d = new Date();
      const stamp = d.toISOString().replace(/[-:TZ.]/g, "").slice(0, 14);
      return `cpt_${stamp}_${Math.random().toString(36).slice(2, 8)}`;
    }

    async function createTask(prompt, referenceImageUrl = null, modelId = "seedream_4") {
      const modelOpt = MODEL_OPTIONS.find(m => m.id === modelId);
      
      if (modelOpt.apiType === "gpt4o") {
        const body = {
          filesUrl: referenceImageUrl ? [referenceImageUrl] : [],
          prompt,
          size: "2:3",
          isEnhance: false,
          uploadCn: false,
          nVariants: 1,
          enableFallback: false,
          fallbackModel: "FLUX_MAX"
        };
        const res = await fetch(`${BACKEND_URL}/api/gpt4o-create`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        return res.json();
      }
      
      if (modelOpt.apiType === "flux_kontext") {
        const body = {
          prompt,
          enableTranslation: true,
          aspectRatio: "9:16",
          outputFormat: "png",
          promptUpsampling: false,
          model: "flux-kontext-pro"
        };
        if (referenceImageUrl) {
          body.inputImage = referenceImageUrl;
        }
        const res = await fetch(`${BACKEND_URL}/api/flux-kontext-create`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        return res.json();
      }
      
      const apiModel = referenceImageUrl ? modelOpt.apiEditModel : modelOpt.apiModel;
      let body;
      if (modelId === "ideogram") {
        body = { model: apiModel, input: { prompt, rendering_speed: "BALANCED", style: "AUTO", expand_prompt: true, image_size: "portrait_16_9", num_images: "1", sync_mode: false } };
      } else if (modelId === "imagen4") {
        body = { model: apiModel, input: { prompt, aspect_ratio: "9:16", num_images: "1" } };
      } else if (modelId === "nano_banana") {
        body = referenceImageUrl
          ? { model: apiModel, input: { prompt, image_urls: [referenceImageUrl], output_format: "png", image_size: "9:16" } }
          : { model: apiModel, input: { prompt, output_format: "png", image_size: "9:16" } };
      } else {
        body = referenceImageUrl
          ? { model: apiModel, input: { prompt, image_urls: [referenceImageUrl], image_size: "portrait_16_9", image_resolution: "1K", max_images: 1 } }
          : { model: apiModel, input: { prompt, image_size: "portrait_16_9", image_resolution: "1K", max_images: 1 } };
      }

      const res = await fetch(`${BACKEND_URL}/api/create-task`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      return res.json();
    }

    async function queryTask(taskId, modelId = "seedream_4") {
      const modelOpt = MODEL_OPTIONS.find(m => m.id === modelId);
      let endpoint = "query-task";
      if (modelOpt?.apiType === "gpt4o") endpoint = "gpt4o-query";
      if (modelOpt?.apiType === "flux_kontext") endpoint = "flux-kontext-query";
      const res = await fetch(`${BACKEND_URL}/api/${endpoint}?taskId=${taskId}`);
      return res.json();
    }

    async function pollTask(taskId, maxAttempts = 60, modelId = "seedream_4") {
      const modelOpt = MODEL_OPTIONS.find(m => m.id === modelId);
      
      for (let i = 0; i < maxAttempts; i++) {
        const result = await queryTask(taskId, modelId);
        console.log(`Poll attempt ${i + 1}:`, result);
        
        if (modelOpt?.apiType === "gpt4o") {
          if (result.data?.response?.resultUrls?.[0]) {
            return result.data.response.resultUrls[0];
          }
          if (result.data?.status === "FAILED") throw new Error("Task failed");
        } else if (modelOpt?.apiType === "flux_kontext") {
          if (result.data?.response?.resultImageUrl) {
            return result.data.response.resultImageUrl;
          }
          if (result.data?.errorCode) throw new Error("Task failed");
        } else {
          if (result.data?.state === "success" && result.data?.resultJson) {
            const resultData = JSON.parse(result.data.resultJson);
            const imageUrl = resultData.resultUrls?.[0];
            if (imageUrl) return imageUrl;
          }
          if (result.data?.state === "failed") throw new Error("Task failed");
        }
        
        await new Promise(r => setTimeout(r, 2000));
      }
      throw new Error("Timeout");
    }

    async function getGoogleAccessToken() {
      const res = await fetch(`${BACKEND_URL}/api/google-auth`, { method: "POST" });
      const data = await res.json();
      return data.access_token;
    }

    function decodeHtmlEntities(str) {
      if (typeof str !== 'string') return str;
      return str.replace(/&#39;/g, "'").replace(/&quot;/g, '"').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>');
    }

    async function appendToGoogleSheet(entry, audioLink, audioLength, batchId, batchConceptId, songName, lyric) {
      try {
        const token = await getGoogleAccessToken();
        const row = [
          batchId || "",
          batchConceptId || "",
          entry.song_id || "",
          songName || entry.audio_clip || "",
          lyric || "",
          entry.text_hook || "false",
          entry.prompt,
          audioLength || "",
          entry.video_prompt || "",
          entry.reference_image_name || "",
          audioLink || "",
          entry.generated_image_url,
          entry.status
        ];
        
        const res = await fetch(`${BACKEND_URL}/api/sheets/append`, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${token}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ sheet: "02_Video", values: [row] })
        });
        
        if (!res.ok) throw new Error(`Google Sheets API error: ${res.status}`);
        return await res.json();
      } catch (err) {
        console.error("Failed to append to Google Sheet:", err);
        throw err;
      }
    }

    function buildCSV(rows) {
      const headers = ["timestamp", "concept_id", "prompt", "model", "reference_image_name", "generated_image_url", "video_prompt", "audio_clip", "overlay_text_enabled", "overlay_text", "status"];
      return [headers.join(",")]
        .concat(rows.map((r) => [r.timestamp, r.concept_id, JSON.stringify(r.prompt), r.model, r.reference_image_name || "", r.generated_image_url, JSON.stringify(r.video_prompt || ""), r.audio_clip || "", r.overlay_text_enabled ? "true" : "false", JSON.stringify(r.overlay_text || ""), r.status || "READY"].join(",")))
        .join("\n");
    }

    function downloadCSV(rows, filename = "saved_concepts.csv") {
      const csv = buildCSV(rows);
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function ImageCard({ card, onSave, audioOptions }) {
      const initialClipId = card.clip_id || audioOptions[0]?.clip_id || "";
      const [selectedAudioId, setSelectedAudioId] = useState(initialClipId);
      const [videoPrompt, setVideoPrompt] = useState(card.video_prompt);
      const [hasTextHook, setHasTextHook] = useState(card.text_hook !== "false");
      const [textHook, setTextHook] = useState(card.text_hook !== "false" ? card.text_hook : "we're good");
      const lyricWasIncluded = card.overlay_text_enabled;
      
      const selectedAudio = audioOptions.find(a => String(a.clip_id) === String(selectedAudioId)) || audioOptions[0] || {};

      return (
        <div className="rounded-3xl overflow-hidden border border-neutral-200 bg-white shadow-sm">
          <div className="p-3 flex items-center justify-between text-xs text-neutral-600">
            <span className="px-2 py-1 rounded-full bg-neutral-100 border border-neutral-200">{card.model}</span>
            <span className="px-2 py-1 rounded-full bg-neutral-100 border border-neutral-200">9:16</span>
          </div>
          <div className="relative">
            <img src={card.image_url} alt={card.model} className="w-full aspect-[9/16] object-cover" />
          </div>
          <div className="p-4 grid gap-3">
            <div>
              <label className="text-xs font-medium">Audio</label>
              <select value={selectedAudioId} onChange={(e) => setSelectedAudioId(e.target.value)} className="w-full mt-1 p-2 rounded-xl border border-neutral-300">
                {audioOptions.map((a, i) => {
                  const lyricPreview = a.lyric.split(' ').slice(0, 5).join(' ') + '...';
                  return <option key={i} value={a.clip_id}>{a.song_name} - {lyricPreview} ({a.length})</option>;
                })}
              </select>
            </div>
            <div>
              <label className={`text-xs font-medium flex items-center gap-2 ${lyricWasIncluded ? "opacity-50" : ""}`}>
                <input type="checkbox" className="h-3 w-3" checked={hasTextHook} disabled={lyricWasIncluded} onChange={(e) => setHasTextHook(e.target.checked)} />
                Add text hook
              </label>
              {hasTextHook && (
                <input type="text" value={textHook} onChange={(e) => setTextHook(e.target.value)} className="mt-1 w-full p-2 rounded-xl border border-neutral-300" />
              )}
            </div>
            <div>
              <label className="text-xs font-medium">Video prompt</label>
              <textarea value={videoPrompt} onChange={(e) => setVideoPrompt(e.target.value)} rows={3} className="mt-1 w-full p-2 rounded-xl border border-neutral-300" />
            </div>
            <button onClick={() => onSave({ ...card, clip_id: selectedAudioId, song_id: selectedAudio.song_id, audio_clip: selectedAudio.song_name, audio_link: selectedAudio.audio_link, audio_length: selectedAudio.length, video_prompt: videoPrompt, text_hook: hasTextHook ? textHook : "false" })} className="w-full px-4 py-2 rounded-2xl bg-neutral-900 text-white hover:bg-neutral-800">
              Save Concept
            </button>
          </div>
        </div>
      );
    }

    async function getMaxBatchId() {
      try {
        const token = await getGoogleAccessToken();
        const res = await fetch(
          `${BACKEND_URL}/api/sheets/read?range=02_Video!A2:A`,
          { headers: { "Authorization": `Bearer ${token}` } }
        );
        const data = await res.json();
        const batchIds = (data.values || []).map(row => parseFloat(row[0])).filter(n => !isNaN(n));
        return batchIds.length > 0 ? Math.max(...batchIds) : 0;
      } catch (err) {
        console.error("Failed to fetch max batch_id:", err);
        return 0;
      }
    }

    async function uploadVideo(file) {
      const reader = new FileReader();
      return new Promise((resolve, reject) => {
        reader.onload = async () => {
          try {
            const base64Data = reader.result.split(',')[1];
            const res = await fetch(`${BACKEND_URL}/api/video/upload`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                filename: file.name,
                mimeType: file.type,
                fileData: base64Data
              })
            });
            const data = await res.json();
            resolve(data);
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function appendVideoToSheet(videoPath, filename, audioClipId, textHook, audioOptions, batchId, batchConceptId) {
      const token = await getGoogleAccessToken();
      const audio = audioOptions.find(a => a.clip_id === audioClipId) || audioOptions[0];
      
      const row = [
        batchId || "",
        batchConceptId || "",
        audio.song_id || "",
        audio.song_name || "",
        audio.lyric || "",
        textHook || "false",
        "",
        audio.length || "",
        "",
        "",
        audio.audio_link || "",
        "",
        "video uploaded",
        filename || "",
        videoPath
      ];
      
      const res = await fetch(`${BACKEND_URL}/api/sheets/append`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ sheet: "02_Video", values: [row] })
      });
      
      if (!res.ok) throw new Error(`Google Sheets API error: ${res.status}`);
      return await res.json();
    }

    function MediaUploadTab({ audioOptions }) {
      const [file, setFile] = useState(null);
      const [selectedAudioId, setSelectedAudioId] = useState(audioOptions[0]?.clip_id || "");
      const [hasTextHook, setHasTextHook] = useState(false);
      const [textHook, setTextHook] = useState("we're good");
      const [isUploading, setIsUploading] = useState(false);
      const [uploadHistory, setUploadHistory] = useState([]);
      const [isDragging, setIsDragging] = useState(false);
      
      function handleDragOver(e) {
        e.preventDefault();
        setIsDragging(true);
      }
      
      function handleDragLeave(e) {
        e.preventDefault();
        setIsDragging(false);
      }
      
      function handleDrop(e) {
        e.preventDefault();
        setIsDragging(false);
        const droppedFile = e.dataTransfer.files[0];
        if (droppedFile && (droppedFile.type.startsWith('video/') || droppedFile.type.startsWith('image/'))) {
          setFile(droppedFile);
        }
      }
      
      async function handleUpload() {
        if (!file) {
          alert("Please select a file");
          return;
        }
        
        const isVideo = file.type.startsWith('video/');
        setIsUploading(true);
        try {
          const uploadResult = await uploadVideo(file);
          if (!uploadResult.success) {
            throw new Error('Upload failed: ' + JSON.stringify(uploadResult));
          }
          
          let videoPrompt = "";
          if (!isVideo) {
            try {
              const reader = new FileReader();
              const base64Promise = new Promise((resolve) => {
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.readAsDataURL(file);
              });
              const base64Data = await base64Promise;
              
              const descRes = await fetch(`${BACKEND_URL}/api/describe-image`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ imageData: base64Data, mediaType: file.type })
              });
              const descData = await descRes.json();
              videoPrompt = descData.description || "";
            } catch (err) {
              console.error('Failed to describe image:', err);
              alert('Warning: Image description failed. Continuing without description.');
              videoPrompt = "";
            }
          }
          
          const maxBatch = await getMaxBatchId();
          const batchId = maxBatch + 1;
          const batchConceptId = `${batchId}.1`;
          const audio = audioOptions.find(a => a.clip_id === selectedAudioId) || audioOptions[0];
          const fullUrl = `${window.location.origin}${uploadResult.url}`;
          
          const token = await getGoogleAccessToken();
          const row = isVideo ? [
            batchId || "",
            batchConceptId || "",
            audio.song_id || "",
            audio.song_name || "",
            audio.lyric || "",
            hasTextHook ? textHook : "false",
            "",
            audio.length || "",
            "",
            "",
            audio.audio_link || "",
            "",
            "video uploaded",
            fullUrl,
            ""
          ] : [
            batchId || "",
            batchConceptId || "",
            audio.song_id || "",
            audio.song_name || "",
            audio.lyric || "",
            hasTextHook ? textHook : "false",
            "",
            audio.length || "",
            videoPrompt,
            "",
            audio.audio_link || "",
            fullUrl,
            "concept approved"
          ];
          
          const res = await fetch(`${BACKEND_URL}/api/sheets/append`, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${token}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ sheet: "02_Video", values: [row] })
          });
          
          if (!res.ok) throw new Error(`Google Sheets API error: ${res.status}`);
          
          setUploadHistory(prev => [{
            timestamp: new Date().toISOString(),
            filename: file.name,
            type: isVideo ? 'Video' : 'Image',
            path: uploadResult.path,
            audio: audio.song_name || "",
            textHook: hasTextHook ? textHook : "None"
          }, ...prev]);
          
          setFile(null);
          alert(`${isVideo ? 'Video' : 'Image'} uploaded successfully!`);
        } catch (err) {
          alert("Upload failed: " + err.message);
          console.error(err);
        }
        setIsUploading(false);
      }
      
      return (
        <div className="max-w-4xl mx-auto">
          <div className="bg-white rounded-3xl border border-neutral-200 p-6">
            <h2 className="text-xl font-semibold mb-4">Upload Media</h2>
            
            <div className="grid gap-4">
              <div>
                <label className="text-sm font-medium">Video or Image File</label>
                <div
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                  onDrop={handleDrop}
                  className={`mt-1 p-8 rounded-xl border-2 border-dashed transition-colors ${
                    isDragging ? 'border-blue-500 bg-blue-50' : 'border-neutral-300 bg-neutral-50'
                  }`}
                >
                  <input
                    type="file"
                    accept="video/*,image/*"
                    onChange={(e) => setFile(e.target.files[0])}
                    className="hidden"
                    id="media-upload"
                  />
                  <label htmlFor="media-upload" className="cursor-pointer flex flex-col items-center gap-2">
                    <svg className="w-12 h-12 text-neutral-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    <span className="text-sm text-neutral-600">Drag & drop video or image here or click to browse</span>
                  </label>
                </div>
                {file && (
                  <div className="mt-2 p-2 bg-neutral-100 rounded-lg flex items-center justify-between">
                    <span className="text-sm text-neutral-700">{file.name} ({file.type.startsWith('video/') ? 'Video' : 'Image'})</span>
                    <button onClick={() => setFile(null)} className="text-red-600 hover:text-red-800 text-sm">Remove</button>
                  </div>
                )}
              </div>
              
              <div>
                <label className="text-sm font-medium">Audio Track</label>
                <select
                  value={selectedAudioId}
                  onChange={(e) => setSelectedAudioId(e.target.value)}
                  className="w-full mt-1 p-2 rounded-xl border border-neutral-300"
                >
                  {audioOptions.map((a, i) => {
                    const lyricPreview = a.lyric.split(' ').slice(0, 5).join(' ') + '...';
                    return <option key={i} value={a.clip_id}>{a.song_name} - {lyricPreview} ({a.length})</option>;
                  })}
                </select>
              </div>
              
              <div>
                <label className="flex items-center gap-2 text-sm font-medium">
                  <input
                    type="checkbox"
                    checked={hasTextHook}
                    onChange={(e) => setHasTextHook(e.target.checked)}
                    className="h-4 w-4"
                  />
                  Add text hook
                </label>
                {hasTextHook && (
                  <input
                    type="text"
                    value={textHook}
                    onChange={(e) => setTextHook(e.target.value)}
                    className="mt-2 w-full p-2 rounded-xl border border-neutral-300"
                    placeholder="Enter text hook"
                  />
                )}
              </div>
              
              <button
                onClick={handleUpload}
                disabled={isUploading || !file}
                className="px-4 py-2 rounded-2xl bg-neutral-900 text-white hover:bg-neutral-800 disabled:opacity-60"
              >
                {isUploading ? "Uploading..." : "Upload"}
              </button>
            </div>
          </div>
          
          {uploadHistory.length > 0 && (
            <div className="mt-6">
              <h3 className="text-lg font-semibold mb-2">Upload History</h3>
              <div className="overflow-x-auto border border-neutral-200 rounded-2xl">
                <table className="min-w-full text-sm bg-white">
                  <thead className="bg-neutral-100">
                    <tr>
                      <th className="text-left p-2">Timestamp</th>
                      <th className="text-left p-2">Type</th>
                      <th className="text-left p-2">Filename</th>
                      <th className="text-left p-2">Audio</th>
                      <th className="text-left p-2">Text Hook</th>
                      <th className="text-left p-2">Path</th>
                    </tr>
                  </thead>
                  <tbody>
                    {uploadHistory.map((item, i) => (
                      <tr key={i} className="border-t border-neutral-200">
                        <td className="p-2 whitespace-nowrap">{new Date(item.timestamp).toLocaleString()}</td>
                        <td className="p-2">{item.type}</td>
                        <td className="p-2">{item.filename}</td>
                        <td className="p-2">{item.audio}</td>
                        <td className="p-2">{item.textHook}</td>
                        <td className="p-2 font-mono text-xs">{item.path}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>
      );
    }

    function VideoUploadTab_OLD({ audioOptions }) {
      const [videoFile, setVideoFile] = useState(null);
      const [selectedAudioId, setSelectedAudioId] = useState(audioOptions[0]?.clip_id || "");
      const [hasTextHook, setHasTextHook] = useState(false);
      const [textHook, setTextHook] = useState("we're good");
      const [isUploading, setIsUploading] = useState(false);
      const [uploadHistory, setUploadHistory] = useState([]);
      const [isDragging, setIsDragging] = useState(false);
      
      function handleDragOver(e) {
        e.preventDefault();
        setIsDragging(true);
      }
      
      function handleDragLeave(e) {
        e.preventDefault();
        setIsDragging(false);
      }
      
      function handleDrop(e) {
        e.preventDefault();
        setIsDragging(false);
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('video/')) {
          setVideoFile(file);
        }
      }
      
      async function handleUpload() {
        if (!videoFile) {
          alert("Please select a video file");
          return;
        }
        
        setIsUploading(true);
        try {
          const uploadResult = await uploadVideo(videoFile);
          console.log('Upload result:', uploadResult);
          if (!uploadResult.success) {
            throw new Error('Upload failed: ' + JSON.stringify(uploadResult));
          }
          
          const maxBatch = await getMaxBatchId();
          const batchId = maxBatch + 1;
          const batchConceptId = `${batchId}.1`;
          const fullUrl = `${window.location.origin}${uploadResult.url}`;
          
          await appendVideoToSheet(fullUrl, uploadResult.filename, selectedAudioId, hasTextHook ? textHook : "false", audioOptions, batchId, batchConceptId);
          
          setUploadHistory(prev => [{
            timestamp: new Date().toISOString(),
            filename: videoFile.name,
            videoPath: uploadResult.path,
            audio: audioOptions.find(a => a.clip_id === selectedAudioId)?.song_name || "",
            textHook: hasTextHook ? textHook : "None"
          }, ...prev]);
          
          setVideoFile(null);
          alert("Video uploaded successfully!");
        } catch (err) {
          alert("Upload failed: " + err.message);
          console.error(err);
        }
        setIsUploading(false);
      }
      
      return (
        <div className="max-w-4xl mx-auto">
          <div className="bg-white rounded-3xl border border-neutral-200 p-6">
            <h2 className="text-xl font-semibold mb-4">Upload Video for Processing</h2>
            
            <div className="grid gap-4">
              <div>
                <label className="text-sm font-medium">Video File</label>
                <div
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                  onDrop={handleDrop}
                  className={`mt-1 p-8 rounded-xl border-2 border-dashed transition-colors ${
                    isDragging ? 'border-blue-500 bg-blue-50' : 'border-neutral-300 bg-neutral-50'
                  }`}
                >
                  <input
                    type="file"
                    accept="video/*"
                    onChange={(e) => setVideoFile(e.target.files[0])}
                    className="hidden"
                    id="video-upload"
                  />
                  <label htmlFor="video-upload" className="cursor-pointer flex flex-col items-center gap-2">
                    <svg className="w-12 h-12 text-neutral-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    <span className="text-sm text-neutral-600">Drag & drop video here or click to browse</span>
                  </label>
                </div>
                {videoFile && (
                  <div className="mt-2 p-2 bg-neutral-100 rounded-lg flex items-center justify-between">
                    <span className="text-sm text-neutral-700">{videoFile.name}</span>
                    <button onClick={() => setVideoFile(null)} className="text-red-600 hover:text-red-800 text-sm">Remove</button>
                  </div>
                )}
              </div>
              
              <div>
                <label className="text-sm font-medium">Audio Track</label>
                <select
                  value={selectedAudioId}
                  onChange={(e) => setSelectedAudioId(e.target.value)}
                  className="w-full mt-1 p-2 rounded-xl border border-neutral-300"
                >
                  {audioOptions.map((a, i) => {
                    const lyricPreview = a.lyric.split(' ').slice(0, 5).join(' ') + '...';
                    return <option key={i} value={a.clip_id}>{a.song_name} - {lyricPreview} ({a.length})</option>;
                  })}
                </select>
              </div>
              
              <div>
                <label className="flex items-center gap-2 text-sm font-medium">
                  <input
                    type="checkbox"
                    checked={hasTextHook}
                    onChange={(e) => setHasTextHook(e.target.checked)}
                    className="h-4 w-4"
                  />
                  Add text hook
                </label>
                {hasTextHook && (
                  <input
                    type="text"
                    value={textHook}
                    onChange={(e) => setTextHook(e.target.value)}
                    className="mt-2 w-full p-2 rounded-xl border border-neutral-300"
                    placeholder="Enter text hook"
                  />
                )}
              </div>
              
              <button
                onClick={handleUpload}
                disabled={isUploading || !videoFile}
                className="px-4 py-2 rounded-2xl bg-neutral-900 text-white hover:bg-neutral-800 disabled:opacity-60"
              >
                {isUploading ? "Uploading..." : "Upload & Queue for Processing"}
              </button>
            </div>
          </div>
          
          {uploadHistory.length > 0 && (
            <div className="mt-6">
              <h3 className="text-lg font-semibold mb-2">Upload History</h3>
              <div className="overflow-x-auto border border-neutral-200 rounded-2xl">
                <table className="min-w-full text-sm bg-white">
                  <thead className="bg-neutral-100">
                    <tr>
                      <th className="text-left p-2">Timestamp</th>
                      <th className="text-left p-2">Filename</th>
                      <th className="text-left p-2">Audio</th>
                      <th className="text-left p-2">Text Hook</th>
                      <th className="text-left p-2">Video Path</th>
                    </tr>
                  </thead>
                  <tbody>
                    {uploadHistory.map((item, i) => (
                      <tr key={i} className="border-t border-neutral-200">
                        <td className="p-2 whitespace-nowrap">{new Date(item.timestamp).toLocaleString()}</td>
                        <td className="p-2">{item.filename}</td>
                        <td className="p-2">{item.audio}</td>
                        <td className="p-2">{item.textHook}</td>
                        <td className="p-2 font-mono text-xs">{item.videoPath}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>
      );
    }

    function ImageUploadTab({ audioOptions }) {
      const [imageFile, setImageFile] = useState(null);
      const [selectedAudioId, setSelectedAudioId] = useState(audioOptions[0]?.clip_id || "");
      const [hasTextHook, setHasTextHook] = useState(false);
      const [textHook, setTextHook] = useState("we're good");
      const [isUploading, setIsUploading] = useState(false);
      const [uploadHistory, setUploadHistory] = useState([]);
      const [isDragging, setIsDragging] = useState(false);
      
      function handleDragOver(e) {
        e.preventDefault();
        setIsDragging(true);
      }
      
      function handleDragLeave(e) {
        e.preventDefault();
        setIsDragging(false);
      }
      
      function handleDrop(e) {
        e.preventDefault();
        setIsDragging(false);
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) {
          setImageFile(file);
        }
      }
      
      async function handleUpload() {
        if (!imageFile) {
          alert("Please select an image file");
          return;
        }
        
        setIsUploading(true);
        try {
          const uploadResult = await uploadVideo(imageFile);
          console.log('Upload result:', uploadResult);
          if (!uploadResult.success) {
            throw new Error('Upload failed: ' + JSON.stringify(uploadResult));
          }
          
          const maxBatch = await getMaxBatchId();
          const batchId = maxBatch + 1;
          const batchConceptId = `${batchId}.1`;
          const audio = audioOptions.find(a => a.clip_id === selectedAudioId) || audioOptions[0];
          const fullUrl = `${window.location.origin}${uploadResult.url}`;
          
          const token = await getGoogleAccessToken();
          const row = [
            batchId || "",
            batchConceptId || "",
            audio.song_id || "",
            audio.song_name || "",
            audio.lyric || "",
            hasTextHook ? textHook : "false",
            "",
            audio.length || "",
            "",
            "",
            audio.audio_link || "",
            fullUrl,
            "image uploaded"
          ];
          
          const res = await fetch(`${BACKEND_URL}/api/sheets/append`, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${token}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ sheet: "02_Video", values: [row] })
          });
          
          if (!res.ok) throw new Error(`Google Sheets API error: ${res.status}`);
          
          setUploadHistory(prev => [{
            timestamp: new Date().toISOString(),
            filename: imageFile.name,
            imagePath: uploadResult.path,
            audio: audio.song_name || "",
            textHook: hasTextHook ? textHook : "None"
          }, ...prev]);
          
          setImageFile(null);
          alert("Image uploaded successfully!");
        } catch (err) {
          alert("Upload failed: " + err.message);
          console.error(err);
        }
        setIsUploading(false);
      }
      
      return (
        <div className="max-w-4xl mx-auto">
          <div className="bg-white rounded-3xl border border-neutral-200 p-6">
            <h2 className="text-xl font-semibold mb-4">Upload Image</h2>
            
            <div className="grid gap-4">
              <div>
                <label className="text-sm font-medium">Image File</label>
                <div
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                  onDrop={handleDrop}
                  className={`mt-1 p-8 rounded-xl border-2 border-dashed transition-colors ${
                    isDragging ? 'border-blue-500 bg-blue-50' : 'border-neutral-300 bg-neutral-50'
                  }`}
                >
                  <input
                    type="file"
                    accept="image/*"
                    onChange={(e) => setImageFile(e.target.files[0])}
                    className="hidden"
                    id="image-upload"
                  />
                  <label htmlFor="image-upload" className="cursor-pointer flex flex-col items-center gap-2">
                    <svg className="w-12 h-12 text-neutral-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    <span className="text-sm text-neutral-600">Drag & drop image here or click to browse</span>
                  </label>
                </div>
                {imageFile && (
                  <div className="mt-2 p-2 bg-neutral-100 rounded-lg flex items-center justify-between">
                    <span className="text-sm text-neutral-700">{imageFile.name}</span>
                    <button onClick={() => setImageFile(null)} className="text-red-600 hover:text-red-800 text-sm">Remove</button>
                  </div>
                )}
              </div>
              
              <div>
                <label className="text-sm font-medium">Audio Track</label>
                <select
                  value={selectedAudioId}
                  onChange={(e) => setSelectedAudioId(e.target.value)}
                  className="w-full mt-1 p-2 rounded-xl border border-neutral-300"
                >
                  {audioOptions.map((a, i) => {
                    const lyricPreview = a.lyric.split(' ').slice(0, 5).join(' ') + '...';
                    return <option key={i} value={a.clip_id}>{a.song_name} - {lyricPreview} ({a.length})</option>;
                  })}
                </select>
              </div>
              
              <div>
                <label className="flex items-center gap-2 text-sm font-medium">
                  <input
                    type="checkbox"
                    checked={hasTextHook}
                    onChange={(e) => setHasTextHook(e.target.checked)}
                    className="h-4 w-4"
                  />
                  Add text hook
                </label>
                {hasTextHook && (
                  <input
                    type="text"
                    value={textHook}
                    onChange={(e) => setTextHook(e.target.value)}
                    className="mt-2 w-full p-2 rounded-xl border border-neutral-300"
                    placeholder="Enter text hook"
                  />
                )}
              </div>
              
              <button
                onClick={handleUpload}
                disabled={isUploading || !imageFile}
                className="px-4 py-2 rounded-2xl bg-neutral-900 text-white hover:bg-neutral-800 disabled:opacity-60"
              >
                {isUploading ? "Uploading..." : "Upload"}
              </button>
            </div>
          </div>
          
          {uploadHistory.length > 0 && (
            <div className="mt-6">
              <h3 className="text-lg font-semibold mb-2">Upload History</h3>
              <div className="overflow-x-auto border border-neutral-200 rounded-2xl">
                <table className="min-w-full text-sm bg-white">
                  <thead className="bg-neutral-100">
                    <tr>
                      <th className="text-left p-2">Timestamp</th>
                      <th className="text-left p-2">Filename</th>
                      <th className="text-left p-2">Audio</th>
                      <th className="text-left p-2">Text Hook</th>
                      <th className="text-left p-2">Image Path</th>
                    </tr>
                  </thead>
                  <tbody>
                    {uploadHistory.map((item, i) => (
                      <tr key={i} className="border-t border-neutral-200">
                        <td className="p-2 whitespace-nowrap">{new Date(item.timestamp).toLocaleString()}</td>
                        <td className="p-2">{item.filename}</td>
                        <td className="p-2">{item.audio}</td>
                        <td className="p-2">{item.textHook}</td>
                        <td className="p-2 font-mono text-xs">{item.imagePath}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>
      );
    }

    function FileManagerTab() {
      const [files, setFiles] = useState([]);
      const [loading, setLoading] = useState(true);

      React.useEffect(() => {
        loadFiles();
      }, []);

      async function loadFiles() {
        setLoading(true);
        try {
          const res = await fetch(`${BACKEND_URL}/api/uploads/list`);
          const data = await res.json();
          setFiles(data.files || []);
        } catch (err) {
          console.error('Failed to load files:', err);
        }
        setLoading(false);
      }

      async function deleteFile(filename) {
        if (!confirm(`Delete ${filename}?`)) return;
        try {
          const res = await fetch(`${BACKEND_URL}/api/uploads/delete/${filename}`, { method: 'DELETE' });
          if (res.ok) {
            loadFiles();
          } else {
            alert('Failed to delete file');
          }
        } catch (err) {
          alert('Error: ' + err.message);
        }
      }

      async function deleteAll() {
        if (!confirm('Are you sure you want to delete ALL files? This cannot be undone.')) return;
        try {
          const res = await fetch(`${BACKEND_URL}/api/uploads/delete-all`, { method: 'DELETE' });
          const data = await res.json();
          if (res.ok) {
            alert(`Deleted ${data.deleted} files`);
            loadFiles();
          } else {
            alert('Failed to delete files');
          }
        } catch (err) {
          alert('Error: ' + err.message);
        }
      }

      function formatSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      }

      function formatDate(timestamp) {
        return new Date(timestamp * 1000).toLocaleString();
      }

      return (
        <div className="max-w-6xl mx-auto">
          <div className="bg-white rounded-3xl border border-neutral-200 p-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-semibold">Uploaded Files ({files.length})</h2>
              <button
                onClick={deleteAll}
                disabled={files.length === 0}
                className="px-4 py-2 rounded-xl bg-red-600 text-white hover:bg-red-700 disabled:opacity-50"
              >
                Delete All
              </button>
            </div>
            
            {loading ? (
              <p className="text-neutral-600">Loading...</p>
            ) : files.length === 0 ? (
              <p className="text-neutral-600">No files uploaded yet</p>
            ) : (
              <div className="overflow-x-auto border border-neutral-200 rounded-2xl">
                <table className="min-w-full text-sm bg-white">
                  <thead className="bg-neutral-100">
                    <tr>
                      <th className="text-left p-3">Filename</th>
                      <th className="text-left p-3">Size</th>
                      <th className="text-left p-3">Modified</th>
                      <th className="text-left p-3">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {files.map((file, i) => (
                      <tr key={i} className="border-t border-neutral-200">
                        <td className="p-3">
                          <a
                            href={`${BACKEND_URL}/uploads/${file.filename}`}
                            target="_blank"
                            rel="noreferrer"
                            className="text-blue-600 hover:underline"
                          >
                            {file.filename}
                          </a>
                        </td>
                        <td className="p-3">{formatSize(file.size)}</td>
                        <td className="p-3">{formatDate(file.modified)}</td>
                        <td className="p-3">
                          <button
                            onClick={() => deleteFile(file.filename)}
                            className="text-red-600 hover:text-red-800"
                          >
                            üóëÔ∏è Delete
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        </div>
      );
    }

    function ConceptBoardMock() {
      const [activeTab, setActiveTab] = useState("generate");
      const [prompt, setPrompt] = useState("");
      const [isEnhancing, setIsEnhancing] = useState(false);
      const [models, setModels] = useState(["seedream_4", "nano_banana"]);
      const [count, setCount] = useState(1);
      const [referenceFile, setReferenceFile] = useState(null);
      const [referencePreview, setReferencePreview] = useState(null);
      const [audioOptions, setAudioOptions] = useState([]);
      const [selectedAudioIndex, setSelectedAudioIndex] = useState(0);
      const [includeLyric, setIncludeLyric] = useState(false);
      const [lyricText, setLyricText] = useState("");
      const [textStyle, setTextStyle] = useState("The text appears slightly off-center and imperfectly aligned, as if hand-placed on a vintage 1970s screenprinted T-shirt. The edges are a bit uneven and the ink looks worn, with slight texture variations where the print didn't fully transfer. Letters show subtle fading and soft bleed into the fabric, giving a warm, sun-washed, timeworn charm.");
      const [includeReference, setIncludeReference] = useState(false);
      const [referenceImages, setReferenceImages] = useState([]);
      const [selectedRefImage, setSelectedRefImage] = useState("");
      const [addTextHook, setAddTextHook] = useState(false);
      const [textHook, setTextHook] = useState("we're good");
      const [isGenerating, setIsGenerating] = useState(false);
      const [cards, setCards] = useState([]);
      const [saved, setSaved] = useState([]);
      const [currentBatchId, setCurrentBatchId] = useState(null);
      const [batchConceptCount, setBatchConceptCount] = useState(0);
      const fileInputRef = useRef(null);

      React.useEffect(() => {
        fetchAudioOptions().then(options => {
          setAudioOptions(options);
          if (options.length > 0) setLyricText(options[0].lyric);
        });
        fetchReferenceImages().then(images => {
          setReferenceImages(images);
        });
      }, []);

      React.useEffect(() => {
        if (includeReference) {
          setModels(prev => prev.filter(m => !["imagen4", "ideogram"].includes(m)));
          if (selectedRefImage) setReferencePreview(selectedRefImage);
        } else {
          setReferencePreview(null);
          setSelectedRefImage("");
        }
      }, [includeReference, selectedRefImage]);

      const selectedAudio = audioOptions[selectedAudioIndex] || {};

      function handleRefChange(file) {
        const f = file ?? fileInputRef.current?.files?.[0] ?? null;
        setReferenceFile(f || null);
        if (f) {
          const reader = new FileReader();
          reader.onload = () => setReferencePreview(reader.result);
          reader.readAsDataURL(f);
        } else {
          setReferencePreview(null);
        }
      }

      async function handleGenerate() {
        if (!prompt.trim()) {
          alert("Enter a prompt.");
          return;
        }
        const perModel = Number.isFinite(count) && count > 0 ? Math.min(Math.max(count, 1), 12) : 3;
        setIsGenerating(true);

        const conceptId = makeConceptId();
        const newCards = [];
        
        try {
          let refImageUrl = null;
          if (referenceFile) {
            alert("Image-to-image requires a publicly accessible URL. Base64/local files are not supported by the API.");
            setIsGenerating(false);
            return;
          }

          const tasks = [];
          for (const modelId of models) {
            for (let i = 0; i < perModel; i++) {
              tasks.push({ modelId, index: i });
            }
          }

          const results = await Promise.all(tasks.map(async ({ modelId, index }) => {
            try {
              const finalPrompt = includeLyric && lyricText ? `${prompt}. Include text overlay that says: "${lyricText}". ${textStyle}` : prompt;
              
              let imgUrl;
              if (modelId === "development") {
                await new Promise(r => setTimeout(r, 500));
                imgUrl = `https://picsum.photos/seed/${Math.random()}/720/1280`;
              } else {
                const taskRes = await createTask(finalPrompt, referencePreview || null, modelId);
                console.log("Create task response:", taskRes);
                const taskId = taskRes.data?.taskId;
                
                if (!taskId) {
                  console.error("No task ID", taskRes);
                  return null;
                }

                console.log("Polling task:", taskId);
                imgUrl = await pollTask(taskId, 60, modelId);
                console.log("Got image URL:", imgUrl);
              }
              
              let videoPrompt = `${prompt}: cinematic slow dolly movement, soft film grain, shallow depth of field, 24fps, gentle parallax, subtle camera drift for emotional focus, light flares and depth layering for realism, smooth motion easing, immersive atmosphere that draws the viewer in`;
              try {
                const vpRes = await fetch(`${BACKEND_URL}/api/generate-video-prompt`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ prompt: finalPrompt })
                });
                const vpData = await vpRes.json();
                if (vpData.videoPrompt) {
                  videoPrompt = vpData.videoPrompt;
                }
              } catch (err) {
                console.error('Failed to generate video prompt:', err);
              }
              
              return {
                id: `${conceptId}-${modelId}-${index}-${Math.random().toString(36).slice(2, 6)}`,
                concept_id: conceptId,
                model: modelId,
                prompt: finalPrompt,
                image_url: imgUrl,
                video_prompt: videoPrompt,
                clip_id: selectedAudio.clip_id || "",
                song_id: selectedAudio.song_id || "",
                audio_clip: selectedAudio.song_name || "",
                audio_link: selectedAudio.audio_link || "",
                audio_length: selectedAudio.length || "",
                reference_image_name: referenceFile?.name ?? null,
                overlay_text_enabled: includeLyric,
                overlay_text: includeLyric ? lyricText : "",
                text_hook: addTextHook ? textHook : "false",
                status: "GENERATED",
              };
            } catch (err) {
              console.error(`Error generating image for ${modelId}:`, err);
              return null;
            }
          }));

          newCards.push(...results.filter(r => r !== null));
        } catch (err) {
          alert("Error generating images: " + err.message);
          console.error(err);
        }

        setCards(newCards);
        setIsGenerating(false);
      }

      async function handleSave(card) {
        // Get or create batch ID
        let batchId = currentBatchId;
        if (!batchId) {
          const maxBatch = await getMaxBatchId();
          batchId = maxBatch + 1;
          setCurrentBatchId(batchId);
          setBatchConceptCount(0);
        }
        
        const newCount = batchConceptCount + 1;
        setBatchConceptCount(newCount);
        const batchConceptId = String(batchId) + '.' + String(newCount);
        
        const entry = {
          timestamp: new Date().toISOString(),
          concept_id: card.concept_id,
          prompt: card.prompt,
          model: card.model,
          reference_image_name: card.reference_image_name,
          generated_image_url: card.image_url,
          video_prompt: card.video_prompt,
          song_id: card.song_id,
          audio_clip: card.audio_clip,
          overlay_text_enabled: card.overlay_text_enabled,
          overlay_text: card.overlay_text,
          text_hook: card.text_hook,
          status: "concept approved",
        };
        
        // Add to local state
        setSaved((prev) => [entry, ...prev]);
        
        // Append to Google Sheet
        try {
          await appendToGoogleSheet(entry, card.audio_link, card.audio_length, batchId, batchConceptId, card.audio_clip, selectedAudio.lyric);
          console.log("Successfully saved to Google Sheet");
        } catch (err) {
          alert("Saved locally but failed to save to Google Sheet: " + err.message);
        }
      }

      const allSelected = useMemo(() => new Set(models), [models]);

      return (
        <div className="min-h-screen bg-neutral-50 text-neutral-900">
          <header className="sticky top-0 z-20 bg-white/80 backdrop-blur border-b border-neutral-200">
            <div className="max-w-6xl mx-auto p-4">
              <h1 className="text-2xl font-semibold">Concept Board</h1>
              <p className="text-sm text-neutral-600">Powered by Kie.AI</p>
              <div className="mt-3 flex gap-2">
                <button
                  onClick={() => setActiveTab("generate")}
                  className={`px-4 py-2 rounded-xl ${activeTab === "generate" ? "bg-neutral-900 text-white" : "bg-white text-neutral-900 border border-neutral-300"}`}
                >
                  Generate Images
                </button>
                <button
                  onClick={() => setActiveTab("upload")}
                  className={`px-4 py-2 rounded-xl ${activeTab === "upload" ? "bg-neutral-900 text-white" : "bg-white text-neutral-900 border border-neutral-300"}`}
                >
                  Upload Media
                </button>
                <button
                  onClick={() => setActiveTab("files")}
                  className={`px-4 py-2 rounded-xl ${activeTab === "files" ? "bg-neutral-900 text-white" : "bg-white text-neutral-900 border border-neutral-300"}`}
                >
                  Manage Files
                </button>
              </div>
            </div>
          </header>

          <main className="max-w-6xl mx-auto p-4">
            {activeTab === "files" ? (
              <FileManagerTab />
            ) : activeTab === "upload" ? (
              <MediaUploadTab audioOptions={audioOptions} />
            ) : (
            <>
            <section className="grid grid-cols-1 md:grid-cols-12 gap-4">
              <div className="md:col-span-8">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-medium">Prompt</label>
                  <button
                    onClick={async () => {
                      if (!prompt.trim()) return;
                      setIsEnhancing(true);
                      try {
                        const res = await fetch(`${BACKEND_URL}/api/enhance-prompt`, {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({ prompt, hasReference: includeReference })
                        });
                        const data = await res.json();
                        setPrompt(data.enhanced);
                      } catch (err) {
                        alert('Failed to enhance prompt: ' + err.message);
                      }
                      setIsEnhancing(false);
                    }}
                    disabled={isEnhancing || !prompt.trim()}
                    className="text-xs px-3 py-1 rounded-lg bg-blue-600 text-white hover:bg-blue-700 disabled:opacity-50"
                  >
                    {isEnhancing ? 'Enhancing...' : 'Enhance Prompt'}
                  </button>
                </div>
                <textarea value={prompt} onChange={(e) => setPrompt(e.target.value)} placeholder="Describe your scene‚Ä¶" className="w-full mt-1 p-3 rounded-2xl border border-neutral-300 focus:outline-none focus:ring-2 focus:ring-neutral-300" rows={3} />
              </div>

              <div className="md:col-span-4 grid gap-3">
                <div>
                  <label className="text-sm font-medium">Models</label>
                  <div className="mt-1 grid gap-2">
                    {MODEL_OPTIONS.map((m) => {
                      const noImageToImage = ["imagen4", "ideogram"].includes(m.id);
                      const isDisabled = includeReference && noImageToImage;
                      return (
                        <label key={m.id} className={`flex items-center gap-2 ${isDisabled ? "opacity-50" : ""}`}>
                          <input
                            type="checkbox"
                            className="h-4 w-4"
                            checked={models.includes(m.id)}
                            disabled={isDisabled}
                            onChange={(e) => {
                              if (e.target.checked) setModels([...models, m.id]);
                              else setModels(models.filter(x => x !== m.id));
                            }}
                          />
                          {m.label}
                        </label>
                      );
                    })}
                  </div>
                </div>

                <div>
                  <label className="text-sm font-medium"># of images per model</label>
                  <input type="number" min={1} max={12} value={count} onChange={(e) => setCount(Number(e.target.value) || 1)} className="w-full mt-1 p-2 rounded-2xl border border-neutral-300" />
                  <p className="mt-1 text-xs text-neutral-500">Bounded 1‚Äì12.</p>
                </div>

                <div>
                  <label className="text-sm font-medium">Audio (default for this batch)</label>
                  <select value={selectedAudioIndex} onChange={(e) => { const idx = Number(e.target.value); setSelectedAudioIndex(idx); setLyricText(audioOptions[idx]?.lyric || ""); }} className="w-full mt-1 p-2 rounded-2xl border border-neutral-300">
                    {audioOptions.map((a, i) => {
                      const lyricPreview = a.lyric.split(' ').slice(0, 5).join(' ') + '...';
                      return <option key={i} value={i}>{a.song_name} - {lyricPreview} ({a.length})</option>;
                    })}
                  </select>
                  <div className="mt-2 flex items-start gap-2 text-sm">
                    <label className={`flex items-center gap-2 ${addTextHook ? "opacity-50" : ""}`}>
                      <input type="checkbox" className="h-4 w-4" checked={includeLyric} disabled={addTextHook} onChange={(e) => { setIncludeLyric(e.target.checked); if (e.target.checked) setAddTextHook(false); }} />
                      Include lyric text on image
                    </label>
                  </div>
                  {includeLyric && (
                    <div className="mt-2 grid gap-2">
                      <div>
                        <label className="text-xs font-medium">Lyric text</label>
                        <textarea value={lyricText} onChange={(e) => setLyricText(e.target.value)} rows={2} className="w-full mt-1 p-2 rounded-2xl border border-neutral-300" />
                      </div>
                      <div>
                        <label className="text-xs font-medium">Text style description</label>
                        <textarea value={textStyle} onChange={(e) => setTextStyle(e.target.value)} rows={3} className="w-full mt-1 p-2 rounded-2xl border border-neutral-300" />
                      </div>
                    </div>
                  )}
                  <div className="mt-2">
                    <label className="flex items-center gap-2 text-sm">
                      <input type="checkbox" className="h-4 w-4" checked={includeReference} onChange={(e) => setIncludeReference(e.target.checked)} />
                      Include reference image
                    </label>
                  </div>
                  {includeReference && (
                    <div className="mt-2">
                      <label className="text-xs font-medium">Select reference image</label>
                      <div className="mt-1 flex flex-wrap gap-2 max-h-48 overflow-y-auto p-2 border border-neutral-300 rounded-xl">
                        {referenceImages.map((url, i) => (
                          <label key={i} className="cursor-pointer">
                            <input type="radio" name="refImage" value={url} checked={selectedRefImage === url} onChange={(e) => setSelectedRefImage(e.target.value)} className="sr-only" />
                            <img src={url} alt={`Ref ${i}`} className={`w-16 h-16 object-cover rounded border-2 ${selectedRefImage === url ? "border-blue-500" : "border-neutral-300"}`} />
                          </label>
                        ))}
                      </div>
                    </div>
                  )}
                  <div className="mt-2">
                    <label className={`flex items-center gap-2 text-sm ${includeLyric ? "opacity-50" : ""}`}>
                      <input type="checkbox" className="h-4 w-4" checked={addTextHook} disabled={includeLyric} onChange={(e) => { setAddTextHook(e.target.checked); if (e.target.checked) setIncludeLyric(false); }} />
                      Add text hook
                    </label>
                  </div>
                  {addTextHook && (
                    <div className="mt-2">
                      <input type="text" value={textHook} onChange={(e) => setTextHook(e.target.value)} className="w-full p-2 rounded-xl border border-neutral-300" />
                    </div>
                  )}
                </div>

                <button onClick={handleGenerate} disabled={isGenerating} className="mt-1 px-4 py-2 rounded-2xl bg-neutral-900 text-white hover:bg-neutral-800 disabled:opacity-60">
                  {isGenerating ? "Generating‚Ä¶" : "Generate"}
                </button>
              </div>
            </section>

            <section className="mt-8">
              {cards.length > 0 ? (
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-5">
                  {cards.map((card) => <ImageCard key={card.id} card={card} onSave={handleSave} audioOptions={audioOptions} />)}
                </div>
              ) : (
                <div className="text-neutral-500 text-sm">No images yet. Enter a prompt and click Generate.</div>
              )}
            </section>

            <section className="mt-10">
              <h2 className="text-lg font-semibold mb-2">Saved Concepts ({saved.length})</h2>
              {saved.length === 0 ? (
                <p className="text-sm text-neutral-600">Nothing saved yet.</p>
              ) : (
                <div className="overflow-x-auto border border-neutral-200 rounded-2xl">
                  <table className="min-w-full text-sm">
                    <thead className="bg-neutral-100">
                      <tr>
                        <th className="text-left p-2">Timestamp</th>
                        <th className="text-left p-2">Concept ID</th>
                        <th className="text-left p-2">Model</th>
                        <th className="text-left p-2">Prompt</th>
                        <th className="text-left p-2">Image URL</th>
                        <th className="text-left p-2">Audio</th>
                        <th className="text-left p-2">Text?</th>
                      </tr>
                    </thead>
                    <tbody>
                      {saved.map((r, i) => (
                        <tr key={i} className="border-t border-neutral-200">
                          <td className="p-2 whitespace-nowrap">{r.timestamp}</td>
                          <td className="p-2 whitespace-nowrap font-mono">{r.concept_id}</td>
                          <td className="p-2 whitespace-nowrap">{r.model}</td>
                          <td className="p-2 max-w-[24rem] truncate" title={r.prompt}>{r.prompt}</td>
                          <td className="p-2 max-w-[18rem] truncate" title={r.generated_image_url}>
                            <a className="text-blue-600 hover:underline" href={r.generated_image_url} target="_blank" rel="noreferrer">{r.generated_image_url}</a>
                          </td>
                          <td className="p-2 whitespace-nowrap">{r.audio_clip}</td>
                          <td className="p-2 whitespace-nowrap">{r.overlay_text_enabled ? "Yes" : "No"}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </section>
            </>
            )}
          </main>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<ConceptBoardMock />);
  </script>
</body>
</html>
